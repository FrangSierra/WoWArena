package durdinstudios.wowarena.misc

import durdinstudios.wowarena.data.models.warcraft.pvp.ArenaBracket
import durdinstudios.wowarena.domain.arena.model.ArenaInfo
import durdinstudios.wowarena.domain.arena.model.CharacterArenaStats
import lecho.lib.hellocharts.model.*
import lecho.lib.hellocharts.util.ChartUtils
import lecho.lib.hellocharts.view.LineChartView
import java.util.*
import java.util.concurrent.TimeUnit


object LineChartUtils {

    fun prepareChartData(chart: LineChartView, stats: List<CharacterArenaStats>) : Boolean{

        val lines = ArrayList<Line>()
        val vs2Values = stats.filter { it.vs2 != null }.map { it.vs2!! to it.timestamp }
        createLine(vs2Values, ArenaBracket.BRACKET_2_VS_2)?.let { lines.add(it) }
        val vs3Values = stats.filter { it.vs3 != null }.map { it.vs3!! to it.timestamp }
        createLine(vs3Values, ArenaBracket.BRACKET_3_VS_3)?.let { lines.add(it) }
        val rbgValues = stats.filter { it.rbg != null }.map { it.rbg!! to it.timestamp }
        createLine(rbgValues, ArenaBracket.RBG)?.let { lines.add(it) }
        if (lines.isEmpty()) return false
        val data = LineChartData(lines)

        val filteredDates = vs2Values.plus(vs3Values).plus(rbgValues).map { it.second }.distinct()

        val axisXValues = getPossibleDatesvalues(filteredDates).map { AxisValue(it.first.toFloat()).setLabel(it.second) }

        data.axisXBottom = Axis() //TIME
                .setValues(axisXValues)
                .setHasLines(true)
                .setHasTiltedLabels(true)

        data.axisYLeft = Axis() //Rating
                .setHasLines(true)
                .setAutoGenerated(true)
                .setHasTiltedLabels(true)

        chart.lineChartData = data
        chart.makeVisible()
        chart.startDataAnimation()
        return true
    }

    private fun getPossibleDatesvalues(filteredDates: List<Long>): List<Pair<Long, String>> {
        return filteredDates.map {
            val date = Date(it)
            val cal = Calendar.getInstance()
            cal.time = date
            val month = cal.get(Calendar.MONTH).plus(1)
            val day = cal.get(Calendar.DAY_OF_MONTH)
            it to "$day/$month"
        }.distinctBy { it.second }
    }

    private fun createLine(info: List<Pair<ArenaInfo, Long>>, bracket: ArenaBracket): Line? {
        val values = ArrayList<PointValue>()
        val filteredValues = info.distinctBy { TimeUnit.MILLISECONDS.toDays(it.second) }
                .filter { it.first.rating > 0 }
                .sortedBy { it.first.rating }

        filteredValues.mapTo(values) {
            PointValue(it.second.toFloat(), it.first.rating.toFloat())
        }

        if (values.size <= 1) return null

        return Line(values).apply {
            color = when (bracket) {
                ArenaBracket.BRACKET_2_VS_2 -> ChartUtils.COLORS[0]
                ArenaBracket.BRACKET_3_VS_3 -> ChartUtils.COLORS[1]
                ArenaBracket.RBG -> ChartUtils.COLORS[2]
            }

            shape = ValueShape.CIRCLE
            isCubic = isCubic
            isFilled = isFilled


            setHasLabels(true)
            setHasLines(true)
            setHasPoints(true)
        }
    }
}